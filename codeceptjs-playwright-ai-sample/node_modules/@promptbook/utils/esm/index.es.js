import { spaceTrim } from 'spacetrim';
export { spaceTrim } from 'spacetrim';
import { format } from 'prettier';
import parserHtml from 'prettier/parser-html';
import moment from 'moment';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

/**
 * This error indicates that the promptbook in a markdown format cannot be parsed into a valid promptbook object
 */
var PromptbookSyntaxError = /** @class */ (function (_super) {
    __extends(PromptbookSyntaxError, _super);
    function PromptbookSyntaxError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'PromptbookSyntaxError';
        Object.setPrototypeOf(_this, PromptbookSyntaxError.prototype);
        return _this;
    }
    return PromptbookSyntaxError;
}(Error));

/**
 * Supported script languages
 */
var SUPPORTED_SCRIPT_LANGUAGES = ['javascript', 'typescript', 'python'];

/**
 * Parses the template and returns the list of all parameter names
 *
 * @param template the template with parameters in {curly} braces
 * @returns the list of parameter names
 *
 * @private within the library
 */
function extractParameters(template) {
    var e_1, _a;
    var matches = template.matchAll(/{\w+}/g);
    var parameterNames = [];
    try {
        for (var matches_1 = __values(matches), matches_1_1 = matches_1.next(); !matches_1_1.done; matches_1_1 = matches_1.next()) {
            var match = matches_1_1.value;
            var parameterName = match[0].slice(1, -1);
            if (!parameterNames.includes(parameterName)) {
                parameterNames.push(parameterName);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (matches_1_1 && !matches_1_1.done && (_a = matches_1.return)) _a.call(matches_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return parameterNames;
}

/**
 * Computes the deepness of the markdown structure.
 *
 * @private within the library
 */
function countMarkdownStructureDeepness(markdownStructure) {
    var e_1, _a;
    var maxDeepness = 0;
    try {
        for (var _b = __values(markdownStructure.sections), _c = _b.next(); !_c.done; _c = _b.next()) {
            var section = _c.value;
            maxDeepness = Math.max(maxDeepness, countMarkdownStructureDeepness(section));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return maxDeepness + 1;
}

/**
 * The maximum number of iterations for a loops
 */
var LOOP_LIMIT = 1000;

/**
 * This error type indicates that the error should not happen and its last check before crashing with some other error
 */
var UnexpectedError = /** @class */ (function (_super) {
    __extends(UnexpectedError, _super);
    function UnexpectedError(message) {
        var _this = _super.call(this, spaceTrim(function (block) { return "\n                    ".concat(block(message), "\n\n                    Note: This error should not happen.\n                    It's probbably a bug in the promptbook library\n\n                    Please report issue:\n                    https://github.com/webgptorg/promptbook/issues\n\n                    Or contact us on me@pavolhejny.com\n\n                "); })) || this;
        _this.name = 'UnexpectedError';
        Object.setPrototypeOf(_this, UnexpectedError.prototype);
        return _this;
    }
    return UnexpectedError;
}(Error));

/**
 * Parse a markdown string into a MarkdownStructure object.
 *
 * Note: This function does work with code blocks
 * Note: This function does not work with markdown comments
 *
 * @param markdown The markdown string to parse.
 * @returns The MarkdownStructure object.
 *
 * @private within the library
 */
function markdownToMarkdownStructure(markdown) {
    var e_1, _a;
    var lines = markdown.split('\n');
    var root = { level: 0, title: '', contentLines: [], sections: [], parent: null };
    var current = root;
    var isInsideCodeBlock = false;
    try {
        for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
            var line = lines_1_1.value;
            var headingMatch = line.match(/^(?<mark>#{1,6})\s(?<title>.*)/);
            if (isInsideCodeBlock || !headingMatch) {
                if (line.startsWith('```')) {
                    isInsideCodeBlock = !isInsideCodeBlock;
                }
                current.contentLines.push(line);
            }
            else {
                var level = headingMatch.groups.mark.length;
                var title = headingMatch.groups.title.trim();
                var parent_1 = void 0;
                if (level > current.level) {
                    // Note: Going deeper (next section is child of current)
                    parent_1 = current;
                }
                else {
                    // Note: Going up or staying at the same level (next section is sibling or parent or grandparent,... of current)
                    parent_1 = current;
                    var loopLimit = LOOP_LIMIT;
                    while (parent_1.level !== level - 1) {
                        if (loopLimit-- < 0) {
                            throw new UnexpectedError('Loop limit reached during parsing of markdown structure in `markdownToMarkdownStructure`');
                        }
                        if (parent_1.parent === null /* <- Note: We are in root */) {
                            // [ðŸŒ»]
                            throw new Error(spaceTrim("\n                                The file has an invalid structure.\n                                The markdown file must have exactly one top-level section.\n                            "));
                        }
                        parent_1 = parent_1.parent;
                    }
                }
                var section = { level: level, title: title, contentLines: [], sections: [], parent: parent_1 };
                parent_1.sections.push(section);
                current = section;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (root.sections.length === 1) {
        var markdownStructure = parsingMarkdownStructureToMarkdownStructure(root.sections[0]);
        return markdownStructure;
    }
    // [ðŸŒ»]
    throw new Error('The markdown file must have exactly one top-level section.');
    // return root;
}
/**
 * @private
 */
function parsingMarkdownStructureToMarkdownStructure(parsingMarkdownStructure) {
    var level = parsingMarkdownStructure.level, title = parsingMarkdownStructure.title, contentLines = parsingMarkdownStructure.contentLines, sections = parsingMarkdownStructure.sections;
    return {
        level: level,
        title: title,
        content: spaceTrim(contentLines.join('\n')),
        sections: sections.map(parsingMarkdownStructureToMarkdownStructure),
    };
}

/**
 * Utility function to extract all list items from markdown
 *
 * Note: It works with both ul and ol
 * Note: It omits list items in code blocks
 * Note: It flattens nested lists
 * Note: It can not work with html syntax and comments
 *
 * @param markdown any valid markdown
 * @returns
 */
function extractAllListItemsFromMarkdown(markdown) {
    var e_1, _a;
    var lines = markdown.split('\n');
    var listItems = [];
    var isInCodeBlock = false;
    try {
        for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
            var line = lines_1_1.value;
            var trimmedLine = line.trim();
            if (trimmedLine.startsWith('```')) {
                isInCodeBlock = !isInCodeBlock;
            }
            if (!isInCodeBlock && (trimmedLine.startsWith('-') || trimmedLine.match(/^\d+\./))) {
                var listItem = trimmedLine.replace(/^-|\d+\./, '').trim();
                listItems.push(listItem);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return listItems;
}

/**
 * Makes first letter of a string uppercase
 *
 */
function capitalize(word) {
    return word.substring(0, 1).toUpperCase() + word.substring(1);
}

/**
 * Extracts all code blocks from markdown.
 *
 * Note: There are 3 simmilar function:
 * - `extractBlock` just extracts the content of the code block which is also used as build-in function for postprocessing
 * - `extractOneBlockFromMarkdown` extracts exactly one code block with language of the code block
 * - `extractAllBlocksFromMarkdown` extracts all code blocks with language of the code block
 *
 * @param markdown any valid markdown
 * @returns code blocks with language and content
 *
 */
function extractAllBlocksFromMarkdown(markdown) {
    var e_1, _a;
    var codeBlocks = [];
    var lines = markdown.split('\n');
    var currentCodeBlock = null;
    try {
        for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
            var line = lines_1_1.value;
            if (line.startsWith('```')) {
                var language = line.slice(3).trim() || null;
                if (currentCodeBlock === null) {
                    currentCodeBlock = { language: language, content: '' };
                }
                else {
                    if (language !== null) {
                        // [ðŸŒ»]
                        throw new Error("".concat(capitalize(currentCodeBlock.language || 'the'), " code block was not closed and already opening new ").concat(language, " code block"));
                    }
                    codeBlocks.push(currentCodeBlock);
                    currentCodeBlock = null;
                }
            }
            else if (currentCodeBlock !== null) {
                if (currentCodeBlock.content !== '') {
                    currentCodeBlock.content += '\n';
                }
                currentCodeBlock.content += line.split('\\`\\`\\`').join('```') /* <- TODO: Maybe make propper unescape */;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (currentCodeBlock !== null) {
        // [ðŸŒ»]
        throw new Error("".concat(capitalize(currentCodeBlock.language || 'the'), " code block was not closed at the end of the markdown"));
    }
    return codeBlocks;
}

/**
 * Extracts exactly ONE code block from markdown.
 *
 * Note: If there are multiple or no code blocks the function throws an error
 *
 * Note: There are 3 simmilar function:
 * - `extractBlock` just extracts the content of the code block which is also used as build-in function for postprocessing
 * - `extractOneBlockFromMarkdown` extracts exactly one code block with language of the code block
 * - `extractAllBlocksFromMarkdown` extracts all code blocks with language of the code block
 *
 * @param markdown any valid markdown
 * @returns code block with language and content
 */
function extractOneBlockFromMarkdown(markdown) {
    var codeBlocks = extractAllBlocksFromMarkdown(markdown);
    if (codeBlocks.length !== 1) {
        // TODO: Report more specific place where the error happened
        throw new Error(/* <- [ðŸŒ»] */ 'There should be exactly one code block in the markdown');
    }
    return codeBlocks[0];
}
/***
 * TODO: [ðŸ“][ðŸŒ»] !!! Decide of this is internal util, external util OR validator/postprocessor
 */

/**
 * Removes HTML or Markdown comments from a string.
 *
 * @param {string} content - The string to remove comments from.
 * @returns {string} The input string with all comments removed.
 */
function removeContentComments(content) {
    return spaceTrim(content.replace(/<!--(.*?)-->/gs, ''));
}

/**
 * The version of the Promptbook library
 */
var PROMPTBOOK_VERSION = '0.48.1-0';

/**
 * Parses the given script and returns the list of all used variables that are not defined in the script
 *
 * @param script from which to extract the variables
 * @returns the list of variable names
 * @throws {PromptbookSyntaxError} if the script is invalid
 *
 * @private within the promptbookStringToJson
 */
function extractVariables(script) {
    var variables = [];
    script = "(()=>{".concat(script, "})()");
    try {
        for (var i = 0; i < 100 /* <- TODO: This limit to configuration */; i++)
            try {
                eval(script);
            }
            catch (error) {
                if (!(error instanceof ReferenceError)) {
                    throw error;
                }
                var undefinedName = error.message.split(' ')[0];
                /*
                Note: Remapping error
                      From: [ReferenceError: thing is not defined],
                      To:   [Error: Parameter {thing} is not defined],
                */
                if (!undefinedName) {
                    throw error;
                }
                if (script.includes(undefinedName + '(')) {
                    script = "const ".concat(undefinedName, " = ()=>'';") + script;
                }
                else {
                    variables.push(undefinedName);
                    script = "const ".concat(undefinedName, " = '';") + script;
                }
            }
    }
    catch (error) {
        if (!(error instanceof Error)) {
            throw error;
        }
        throw new PromptbookSyntaxError(spaceTrim(function (block) { return "\n                    Can not extract variables from the script\n\n                    ".concat(block(error.name), ": ").concat(block(error.message), "\n                "); }));
    }
    return variables;
}

/**
 * Execution type describes the way how the block is executed
 *
 * @see https://github.com/webgptorg/promptbook#execution-type
 */
var ExecutionTypes = [
    'PROMPT_TEMPLATE',
    'SIMPLE_TEMPLATE',
    'SCRIPT',
    'PROMPT_DIALOG',
    // <- [ðŸ¥»] Insert here when making new command
];

/**
 * Units of text measurement
 */
var EXPECTATION_UNITS = ['CHARACTERS', 'WORDS', 'SENTENCES', 'PARAGRAPHS', 'LINES', 'PAGES'];
/**
 * TODO: [ðŸ’] Unite object for expecting amount and format - remove expectFormat
 * TODO: use one helper type> (string_prompt | string_javascript | string_markdown) & string_template
 */

/**
 * Removes Markdown formatting tags from a string.
 *
 * @param {string} str - The string to remove Markdown tags from.
 * @returns {string} The input string with all Markdown tags removed.
 */
function removeMarkdownFormatting(str) {
    // Remove bold formatting
    str = str.replace(/\*\*(.*?)\*\*/g, '$1');
    // Remove italic formatting
    str = str.replace(/\*(.*?)\*/g, '$1');
    // Remove code formatting
    str = str.replace(/`(.*?)`/g, '$1');
    return str;
}

/**
 * Function parseNumber will parse number from string
 *
 * Unlike Number.parseInt, Number.parseFloat it will never ever result in NaN
 * Note: it also works only with decimal numbers
 *
 * @returns parsed number
 * @throws {PromptbookSyntaxError} if the value is not a number
 *
 * @private within the parseCommand
 */
function parseNumber(value) {
    var originalValue = value;
    if (typeof value === 'number') {
        value = value.toString(); // <- TODO: Maybe more efficient way to do this
    }
    if (typeof value !== 'string') {
        return 0;
    }
    value = value.trim();
    if (value.startsWith('+')) {
        return parseNumber(value.substring(1));
    }
    if (value.startsWith('-')) {
        var number = parseNumber(value.substring(1));
        if (number === 0) {
            return 0; // <- Note: To prevent -0
        }
        return -number;
    }
    value = value.replace(/,/g, '.');
    value = value.toUpperCase();
    if (value === '') {
        return 0;
    }
    if (value === 'â™¾' || value.startsWith('INF')) {
        return Infinity;
    }
    if (value.includes('/')) {
        var _a = __read(value.split('/'), 2), numerator_ = _a[0], denominator_ = _a[1];
        var numerator = parseNumber(numerator_);
        var denominator = parseNumber(denominator_);
        if (denominator === 0) {
            throw new PromptbookSyntaxError("Unable to parse number from \"".concat(originalValue, "\" because denominator is zero"));
        }
        return numerator / denominator;
    }
    if (/^(NAN|NULL|NONE|UNDEFINED|ZERO|NO.*)$/.test(value)) {
        return 0;
    }
    if (value.includes('E')) {
        var _b = __read(value.split('E'), 2), significand = _b[0], exponent = _b[1];
        return parseNumber(significand) * Math.pow(10, parseNumber(exponent));
    }
    if (!/^[0-9.]+$/.test(value) || value.split('.').length > 2) {
        throw new PromptbookSyntaxError("Unable to parse number from \"".concat(originalValue, "\""));
    }
    var num = parseFloat(value);
    if (isNaN(num)) {
        throw new PromptbookSyntaxError("Unexpected NaN when parsing number from \"".concat(originalValue, "\""));
    }
    return num;
}
/**
 * TODO: Maybe use sth. like safe-eval in fraction/calculation case @see https://www.npmjs.com/package/safe-eval
 */

/**
 * Parses one line of ul/ol to command
 *
 * @returns parsed command object
 * @throws {PromptbookSyntaxError} if the command is invalid
 *
 * @private within the promptbookStringToJson
 */
function parseCommand(listItem) {
    var e_1, _a;
    if (listItem.includes('\n') || listItem.includes('\r')) {
        throw new PromptbookSyntaxError('Command can not contain new line characters:');
    }
    var type = listItem.trim();
    type = type.split('`').join('');
    type = type.split('"').join('');
    type = type.split("'").join('');
    type = type.split('~').join('');
    type = type.split('[').join('');
    type = type.split(']').join('');
    type = type.split('(').join('');
    type = type.split(')').join('');
    type = normalizeTo_SCREAMING_CASE(type);
    type = type.split('DIALOGUE').join('DIALOG');
    var listItemParts = listItem
        .split(' ')
        .map(function (part) { return part.trim(); })
        .filter(function (item) { return item !== ''; })
        .filter(function (item) { return !/^PTBK$/i.test(item); })
        .filter(function (item) { return !/^PROMPTBOOK$/i.test(item); })
        .map(removeMarkdownFormatting);
    if (type.startsWith('URL') ||
        type.startsWith('PTBK_URL') ||
        type.startsWith('PTBKURL') ||
        type.startsWith('PROMPTBOOK_URL') ||
        type.startsWith('PROMPTBOOKURL') ||
        type.startsWith('HTTPS')) {
        if (!(listItemParts.length === 2 || (listItemParts.length === 1 && type.startsWith('HTTPS')))) {
            throw new PromptbookSyntaxError(spaceTrim("\n                        Invalid PROMPTBOOK_URL command:\n\n                        - ".concat(listItem, "\n                    ")));
        }
        var promptbookUrlString = listItemParts.pop();
        var promptbookUrl = new URL(promptbookUrlString);
        if (promptbookUrl.protocol !== 'https:') {
            throw new PromptbookSyntaxError(spaceTrim("\n                        Invalid PROMPTBOOK_URL command:\n\n                        - ".concat(listItem, "\n\n                        Protocol must be HTTPS\n                    ")));
        }
        if (promptbookUrl.hash !== '') {
            throw new PromptbookSyntaxError(spaceTrim("\n                        Invalid PROMPTBOOK_URL command:\n\n                        - ".concat(listItem, "\n\n                        URL must not contain hash\n                        Hash is used for identification of the prompt template in the pipeline\n                    ")));
        }
        return {
            type: 'PROMPTBOOK_URL',
            promptbookUrl: promptbookUrl,
        };
    }
    else if (type.startsWith('PROMPTBOOK_VERSION') || type.startsWith('PTBK_VERSION')) {
        if (listItemParts.length !== 2) {
            throw new PromptbookSyntaxError(spaceTrim("\n                        Invalid PROMPTBOOK_VERSION command:\n\n                        - ".concat(listItem, "\n                    ")));
        }
        var promptbookVersion = listItemParts.pop();
        // TODO: Validate version
        return {
            type: 'PROMPTBOOK_VERSION',
            promptbookVersion: promptbookVersion,
        };
    }
    else if (type.startsWith('EXECUTE') ||
        type.startsWith('EXEC') ||
        type.startsWith('PROMPT_DIALOG') ||
        type.startsWith('SIMPLE_TEMPLATE')) {
        var executionTypes = ExecutionTypes.filter(function (executionType) { return type.includes(executionType); });
        if (executionTypes.length !== 1) {
            throw new PromptbookSyntaxError(spaceTrim(function (block) { return "\n                        Unknown execution type in command:\n\n                        - ".concat(listItem, "\n\n                        Supported execution types are:\n                        ").concat(block(ExecutionTypes.join(', ')), "\n                    "); }));
        }
        return {
            type: 'EXECUTE',
            executionType: executionTypes[0],
        };
    }
    else if (type.startsWith('MODEL')) {
        // TODO: Make this more elegant and dynamically
        if (type.startsWith('MODEL_VARIANT')) {
            if (type === 'MODEL_VARIANT_CHAT') {
                return {
                    type: 'MODEL',
                    key: 'modelVariant',
                    value: 'CHAT',
                };
            }
            else if (type === 'MODEL_VARIANT_COMPLETION') {
                return {
                    type: 'MODEL',
                    key: 'modelVariant',
                    value: 'COMPLETION',
                };
            }
            else {
                throw new PromptbookSyntaxError(spaceTrim(function (block) { return "\n                            Unknown model variant in command:\n\n                            - ".concat(listItem, "\n\n                            Supported variants are:\n                            ").concat(block(['CHAT', 'COMPLETION'].join(', ')), "\n                        "); }));
            }
        }
        if (type.startsWith('MODEL_NAME')) {
            return {
                type: 'MODEL',
                key: 'modelName',
                value: listItemParts.pop(),
            };
        }
        else {
            throw new PromptbookSyntaxError(spaceTrim(function (block) { return "\n                          Unknown model key in command:\n\n                          - ".concat(listItem, "\n\n                          Supported model keys are:\n                          ").concat(block(['variant', 'name'].join(', ')), "\n\n                          Example:\n\n                          - MODEL VARIANT Chat\n                          - MODEL NAME gpt-4\n                    "); }));
        }
    }
    else if (type.startsWith('PARAM') ||
        type.startsWith('INPUT_PARAM') ||
        type.startsWith('OUTPUT_PARAM') ||
        listItem.startsWith('{') ||
        listItem.startsWith('> {') /* <- Note: This is a bit hack to parse return parameters defined at the end of each section */) {
        var parametersMatch = listItem.match(/\{(?<parameterName>[a-z0-9_]+)\}[^\S\r\n]*(?<parameterDescription>.*)$/im);
        if (!parametersMatch || !parametersMatch.groups || !parametersMatch.groups.parameterName) {
            throw new PromptbookSyntaxError(spaceTrim("\n                        Invalid parameter in command:\n\n                        - ".concat(listItem, "\n                    ")));
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var _b = parametersMatch.groups, parameterName = _b.parameterName, parameterDescription = _b.parameterDescription;
        if (parameterDescription && parameterDescription.match(/\{(?<parameterName>[a-z0-9_]+)\}/im)) {
            throw new PromptbookSyntaxError(spaceTrim("\n                        Parameter {".concat(parameterName, "} can not contain another parameter in description:\n\n                        - ").concat(listItem, "\n                    ")));
        }
        var isInput = type.startsWith('INPUT');
        var isOutput = type.startsWith('OUTPUT');
        if (listItem.startsWith('> {')) {
            isInput = false;
            isOutput = false;
        }
        return {
            type: 'PARAMETER',
            parameterName: parameterName,
            parameterDescription: parameterDescription.trim() || null,
            isInput: isInput,
            isOutput: isOutput,
        };
    }
    else if (type.startsWith('JOKER')) {
        if (listItemParts.length !== 2) {
            throw new PromptbookSyntaxError(spaceTrim("\n                Invalid JOKER command:\n\n                - ".concat(listItem, "\n            ")));
        }
        var parametersMatch = (listItemParts.pop() || '').match(/^\{(?<parameterName>[a-z0-9_]+)\}$/im);
        if (!parametersMatch || !parametersMatch.groups || !parametersMatch.groups.parameterName) {
            throw new PromptbookSyntaxError(spaceTrim("\n                      Invalid parameter in command:\n\n                      - ".concat(listItem, "\n                  ")));
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var parameterName = parametersMatch.groups.parameterName;
        return {
            type: 'JOKER',
            parameterName: parameterName,
        };
    }
    else if (type.startsWith('POSTPROCESS') || type.startsWith('POST_PROCESS')) {
        if (listItemParts.length !== 2) {
            throw new PromptbookSyntaxError(spaceTrim("\n                Invalid POSTPROCESSING command:\n\n                - ".concat(listItem, "\n            ")));
        }
        var functionName = listItemParts.pop();
        return {
            type: 'POSTPROCESS',
            functionName: functionName,
        };
    }
    else if (type.startsWith('EXPECT_JSON')) {
        return {
            type: 'EXPECT_FORMAT',
            format: 'JSON',
        };
        // [ðŸ¥¤]
    }
    else if (type.startsWith('EXPECT')) {
        try {
            listItemParts.shift();
            var sign = void 0;
            var signRaw = listItemParts.shift();
            if (/^exact/i.test(signRaw)) {
                sign = 'EXACTLY';
            }
            else if (/^min/i.test(signRaw)) {
                sign = 'MINIMUM';
            }
            else if (/^max/i.test(signRaw)) {
                sign = 'MAXIMUM';
            }
            else {
                throw new PromptbookSyntaxError("Invalid sign \"".concat(signRaw, "\", expected EXACTLY, MIN or MAX"));
            }
            var amountRaw = listItemParts.shift();
            var amount = parseNumber(amountRaw);
            if (amount < 0) {
                throw new PromptbookSyntaxError('Amount must be positive number or zero');
            }
            if (amount !== Math.floor(amount)) {
                throw new PromptbookSyntaxError('Amount must be whole number');
            }
            var unitRaw = listItemParts.shift();
            var unit = undefined;
            try {
                for (var EXPECTATION_UNITS_1 = __values(EXPECTATION_UNITS), EXPECTATION_UNITS_1_1 = EXPECTATION_UNITS_1.next(); !EXPECTATION_UNITS_1_1.done; EXPECTATION_UNITS_1_1 = EXPECTATION_UNITS_1.next()) {
                    var existingUnit = EXPECTATION_UNITS_1_1.value;
                    var existingUnitText = existingUnit;
                    existingUnitText = existingUnitText.substring(0, existingUnitText.length - 1);
                    if (existingUnitText === 'CHARACTER') {
                        existingUnitText = 'CHAR';
                    }
                    if (new RegExp("^".concat(existingUnitText.toLowerCase())).test(unitRaw.toLowerCase()) ||
                        new RegExp("^".concat(unitRaw.toLowerCase())).test(existingUnitText.toLowerCase())) {
                        if (unit !== undefined) {
                            throw new PromptbookSyntaxError("Ambiguous unit \"".concat(unitRaw, "\""));
                        }
                        unit = existingUnit;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (EXPECTATION_UNITS_1_1 && !EXPECTATION_UNITS_1_1.done && (_a = EXPECTATION_UNITS_1.return)) _a.call(EXPECTATION_UNITS_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (unit === undefined) {
                throw new PromptbookSyntaxError("Invalid unit \"".concat(unitRaw, "\""));
            }
            return {
                type: 'EXPECT_AMOUNT',
                sign: sign,
                unit: unit,
                amount: amount,
            };
        }
        catch (error) {
            if (!(error instanceof Error)) {
                throw error;
            }
            throw new PromptbookSyntaxError(spaceTrim("\n                  Invalid EXPECT command; ".concat(error.message, ":\n\n                  - ").concat(listItem, "\n              ")));
        }
        /*
    } else if (type.startsWith('__________________')) {
        // <- [ðŸ¥»] Insert here when making new command
    */
    }
    else {
        throw new PromptbookSyntaxError(spaceTrim("\n                    Unknown command:\n\n                    - ".concat(listItem, "\n\n                    Supported commands are:\n                    - PROMPTBOOK_URL <url>\n                    - PROMPTBOOK_VERSION <version>\n                    - EXECUTE PROMPT TEMPLATE\n                    - EXECUTE SIMPLE TEMPLATE\n                    -         SIMPLE TEMPLATE\n                    - EXECUTE SCRIPT\n                    - EXECUTE PROMPT_DIALOG'\n                    -         PROMPT_DIALOG'\n                    - MODEL NAME <name>\n                    - MODEL VARIANT <\"Chat\"|\"Completion\">\n                    - INPUT  PARAM {<name>} <description>\n                    - OUTPUT PARAM {<name>} <description>\n                    - POSTPROCESS `{functionName}`\n                    - JOKER {<name>}\n                    - EXPECT JSON\n                    - EXPECT <\"Exactly\"|\"Min\"|\"Max\"> <number> <\"Chars\"|\"Words\"|\"Sentences\"|\"Paragraphs\"|\"Pages\">\n\n                ")));
    }
}

/**
 * Removes emojis from a string and fix whitespaces
 *
 * @param text with emojis
 * @returns text without emojis
 */
function removeEmojis(text) {
    // Replace emojis (and also ZWJ sequence) with hyphens
    text = text.replace(/(\p{Extended_Pictographic})\p{Modifier_Symbol}/gu, '$1');
    text = text.replace(/(\p{Extended_Pictographic})[\u{FE00}-\u{FE0F}]/gu, '$1');
    text = text.replace(/(\p{Extended_Pictographic})(\u{200D}\p{Extended_Pictographic})*/gu, '$1');
    text = text.replace(/\p{Extended_Pictographic}/gu, '');
    return text;
}

/**
 * Function normalizes title to name which can be used as identifier
 */
function titleToName(value) {
    value = removeEmojis(value);
    value = normalizeToKebabCase(value);
    // TODO: [ðŸ§ ] Maybe warn or add some padding to short name which are not good identifiers
    return value;
}

/**
 * Parse promptbook from string format to JSON format
 *
 * @throws {PromptbookSyntaxError} if the promptbook string is not valid
 *
 * Note: This function does not validate logic of the pipeline only the syntax
 */
function promptbookStringToJson(promptbookString) {
    var e_1, _a, e_2, _b;
    var promptbookJson = {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        title: undefined /* <- Note: Putting here placeholder to keep `title` on top at final JSON */,
        promptbookUrl: undefined /* <- Note: Putting here placeholder to keep `promptbookUrl` on top at final JSON */,
        promptbookVersion: PROMPTBOOK_VERSION,
        description: undefined /* <- Note: Putting here placeholder to keep `description` on top at final JSON */,
        parameters: [],
        promptTemplates: [],
    };
    // =============================================================
    // Note: 1ï¸âƒ£ Normalization of the PROMPTBOOK string
    promptbookString = removeContentComments(promptbookString);
    promptbookString = promptbookString.replaceAll(/`\{(?<parameterName>[a-z0-9_]+)\}`/gi, '{$<parameterName>}');
    promptbookString = promptbookString.replaceAll(/`->\s+\{(?<parameterName>[a-z0-9_]+)\}`/gi, '-> {$<parameterName>}');
    // =============================================================
    ///Note: 2ï¸âƒ£ Function for adding parameters
    var addParam = function (parameterCommand) {
        var parameterName = parameterCommand.parameterName, parameterDescription = parameterCommand.parameterDescription, isInput = parameterCommand.isInput, isOutput = parameterCommand.isOutput;
        var existingParameter = promptbookJson.parameters.find(function (parameter) { return parameter.name === parameterName; });
        if (existingParameter &&
            existingParameter.description &&
            existingParameter.description !== parameterDescription &&
            parameterDescription) {
            throw new PromptbookSyntaxError(spaceTrim(function (block) { return "\n                        Parameter {".concat(parameterName, "} is defined multiple times with different description.\n\n                        First definition:\n                        ").concat(block(existingParameter.description || '[undefined]'), "\n\n                        Second definition:\n                        ").concat(block(parameterDescription || '[undefined]'), "\n                    "); }));
        }
        if (existingParameter) {
            if (parameterDescription) {
                existingParameter.description = parameterDescription;
            }
        }
        else {
            promptbookJson.parameters.push({
                name: parameterName,
                description: parameterDescription || undefined,
                isInput: isInput,
                isOutput: isOutput,
            });
        }
    };
    // =============================================================
    // Note: 3ï¸âƒ£ Parse the dynamic part - the template pipeline
    var markdownStructure = markdownToMarkdownStructure(promptbookString);
    var markdownStructureDeepness = countMarkdownStructureDeepness(markdownStructure);
    if (markdownStructureDeepness !== 2) {
        throw new PromptbookSyntaxError(spaceTrim("\n                Invalid markdown structure.\n                The markdown must have exactly 2 levels of headings (one top-level section and one section for each template).\n                Now it has ".concat(markdownStructureDeepness, " levels of headings.\n            ")));
    }
    promptbookJson.title = markdownStructure.title;
    // TODO: [1] DRY description
    var description = markdownStructure.content;
    // Note: Remove codeblocks
    description = description.split(/^```.*^```/gms).join('');
    //Note: Remove lists and return statement
    description = description.split(/^(?:(?:-)|(?:\d\))|(?:`?->))\s+.*$/gm).join('');
    description = spaceTrim(description);
    if (description === '') {
        description = undefined;
    }
    promptbookJson.description = description;
    var defaultModelRequirements = {};
    var listItems = extractAllListItemsFromMarkdown(markdownStructure.content);
    try {
        for (var listItems_1 = __values(listItems), listItems_1_1 = listItems_1.next(); !listItems_1_1.done; listItems_1_1 = listItems_1.next()) {
            var listItem = listItems_1_1.value;
            var command = parseCommand(listItem);
            switch (command.type) {
                case 'PROMPTBOOK_URL':
                    promptbookJson.promptbookUrl = command.promptbookUrl.href;
                    break;
                case 'PROMPTBOOK_VERSION':
                    promptbookJson.promptbookVersion = command.promptbookVersion;
                    break;
                case 'MODEL':
                    defaultModelRequirements[command.key] = command.value;
                    break;
                case 'PARAMETER':
                    addParam(command);
                    break;
                default:
                    throw new PromptbookSyntaxError("Command ".concat(command.type, " is not allowed in the head of the promptbook ONLY at the prompt template block"));
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (listItems_1_1 && !listItems_1_1.done && (_a = listItems_1.return)) _a.call(listItems_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var _loop_1 = function (section) {
        var e_3, _e, e_4, _f, e_5, _g;
        // TODO: Parse prompt template description (the content out of the codeblock and lists)
        var templateModelRequirements = __assign({}, defaultModelRequirements);
        var listItems_3 = extractAllListItemsFromMarkdown(section.content);
        var dependentParameterNames = [];
        var executionType = 'PROMPT_TEMPLATE';
        var jokers = [];
        var postprocessing = [];
        var expectAmount = {};
        var expectFormat = undefined;
        var isExecutionTypeChanged = false;
        try {
            for (var listItems_2 = (e_3 = void 0, __values(listItems_3)), listItems_2_1 = listItems_2.next(); !listItems_2_1.done; listItems_2_1 = listItems_2.next()) {
                var listItem = listItems_2_1.value;
                var command = parseCommand(listItem);
                switch (command.type) {
                    case 'JOKER':
                        jokers.push(command.parameterName);
                        dependentParameterNames.push(command.parameterName);
                        break;
                    case 'EXECUTE':
                        if (isExecutionTypeChanged) {
                            throw new PromptbookSyntaxError('Execution type is already defined in the prompt template. It can be defined only once.');
                        }
                        executionType = command.executionType;
                        isExecutionTypeChanged = true;
                        break;
                    case 'MODEL':
                        templateModelRequirements[command.key] = command.value;
                        break;
                    case 'PARAMETER':
                        // Note: This is just for detecting resulitng parameter name
                        addParam(command);
                        break;
                    case 'POSTPROCESS':
                        postprocessing.push(command.functionName);
                        break;
                    case 'EXPECT_AMOUNT':
                        // eslint-disable-next-line no-case-declarations
                        var unit = command.unit.toLowerCase();
                        expectAmount[unit] = expectAmount[unit] || {};
                        if (command.sign === 'MINIMUM' || command.sign === 'EXACTLY') {
                            if (expectAmount[unit].min !== undefined) {
                                throw new PromptbookSyntaxError("Already defined minumum ".concat(expectAmount[unit].min, " ").concat(command.unit.toLowerCase(), ", now trying to redefine it to ").concat(command.amount));
                            }
                            expectAmount[unit].min = command.amount;
                        } /* not else */
                        if (command.sign === 'MAXIMUM' || command.sign === 'EXACTLY') {
                            if (expectAmount[unit].max !== undefined) {
                                throw new PromptbookSyntaxError("Already defined maximum ".concat(expectAmount[unit].max, " ").concat(command.unit.toLowerCase(), ", now trying to redefine it to ").concat(command.amount));
                            }
                            expectAmount[unit].max = command.amount;
                        }
                        break;
                    case 'EXPECT_FORMAT':
                        if (expectFormat !== undefined && command.format !== expectFormat) {
                            throw new PromptbookSyntaxError("Expect format is already defined to \"".concat(expectFormat, "\". Now you try to redefine it by \"").concat(command.format, "\"."));
                        }
                        expectFormat = command.format;
                        break;
                    default:
                        throw new PromptbookSyntaxError("Command ".concat(command.type, " is not allowed in the block of the prompt template ONLY at the head of the promptbook"));
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (listItems_2_1 && !listItems_2_1.done && (_e = listItems_2.return)) _e.call(listItems_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        var _h = extractOneBlockFromMarkdown(section.content), language = _h.language, content = _h.content;
        if (executionType === 'SCRIPT') {
            if (!language) {
                throw new PromptbookSyntaxError('You must specify the language of the script in the prompt template');
            }
            else if (!SUPPORTED_SCRIPT_LANGUAGES.includes(language)) {
                throw new PromptbookSyntaxError(spaceTrim(function (block) { return "\n                            Script language ".concat(language, " is not supported.\n\n                            Supported languages are:\n                            ").concat(block(SUPPORTED_SCRIPT_LANGUAGES.join(', ')), "\n\n                        "); }));
            }
        }
        var lastLine = section.content.split('\n').pop();
        var match = /^->\s*\{(?<resultingParamName>[a-z0-9_]+)\}/im.exec(lastLine);
        if (!match || match.groups === undefined || match.groups.resultingParamName === undefined) {
            throw new PromptbookSyntaxError(spaceTrim(function (block) { return "\n                        Invalid template - each section must end with \"-> {...}\"\n\n                        Invalid section:\n                        ".concat(block(
            // TODO: Show code of invalid sections each time + DRY
            section.content
                .split('\n')
                .map(function (line) { return "> ".concat(line); })
                .join('\n')), "\n                        "); }));
        }
        var resultingParameterName = match.groups.resultingParamName;
        // TODO: [1] DRY description
        var description_1 = section.content;
        // Note: Remove codeblocks
        description_1 = description_1.split(/^```.*^```/gms).join('');
        //Note: Remove lists and return statement
        description_1 = description_1.split(/^(?:(?:-)|(?:\d\))|(?:`?->))\s+.*$/gm).join('');
        description_1 = spaceTrim(description_1);
        if (description_1 === '') {
            description_1 = undefined;
        }
        if (Object.keys(jokers).length === 0) {
            jokers = undefined;
        }
        if (Object.keys(expectAmount).length === 0) {
            expectAmount = undefined;
        }
        if (Object.keys(postprocessing).length === 0) {
            postprocessing = undefined;
        }
        try {
            for (var _j = (e_4 = void 0, __values(__spreadArray(__spreadArray(__spreadArray([], __read(extractParameters(section.title)), false), __read(extractParameters(description_1 || '')), false), __read(extractParameters(content)), false))), _k = _j.next(); !_k.done; _k = _j.next()) {
                var parameterName = _k.value;
                dependentParameterNames.push(parameterName);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_k && !_k.done && (_f = _j.return)) _f.call(_j);
            }
            finally { if (e_4) throw e_4.error; }
        }
        if (executionType === 'SCRIPT') {
            try {
                for (var _l = (e_5 = void 0, __values(extractVariables(content))), _m = _l.next(); !_m.done; _m = _l.next()) {
                    var parameterName = _m.value;
                    dependentParameterNames.push(parameterName);
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_m && !_m.done && (_g = _l.return)) _g.call(_l);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
        dependentParameterNames = __spreadArray([], __read(new Set(dependentParameterNames)), false);
        promptbookJson.promptTemplates.push({
            name: titleToName(section.title),
            title: section.title,
            description: description_1,
            dependentParameterNames: dependentParameterNames,
            executionType: executionType,
            jokers: jokers,
            postprocessing: postprocessing,
            expectations: expectAmount,
            expectFormat: expectFormat,
            modelRequirements: templateModelRequirements,
            contentLanguage: executionType === 'SCRIPT' ? language : undefined,
            content: content,
            resultingParameterName: resultingParameterName,
        });
    };
    try {
        for (var _c = __values(markdownStructure.sections), _d = _c.next(); !_d.done; _d = _c.next()) {
            var section = _d.value;
            _loop_1(section);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_2) throw e_2.error; }
    }
    // =============================================================
    return promptbookJson;
}
/**
 * TODO: Report here line/column of error
 * TODO: Use spaceTrim more effectively
 * TODO: [ðŸ§ ] Parameter flags - isInput, isOutput, isInternal
 */

/**
 * Add or modify an auto-generated section in a markdown file
 *
 * @private within the library
 */
function addAutoGeneratedSection(content, options) {
    var sectionName = options.sectionName, sectionContent = options.sectionContent;
    var warningLine = "<!-- \u26A0\uFE0F WARNING: This section was auto-generated -->";
    var sectionRegex = new RegExp("<!--".concat(sectionName, "-->([\\s\\S]*?)<!--/").concat(sectionName, "-->"), 'g');
    var sectionMatch = content.match(sectionRegex);
    if (sectionMatch) {
        return content.replace(sectionRegex, spaceTrim(function (block) { return "\n                    <!--".concat(sectionName, "-->\n                    ").concat(block(warningLine), "\n                    ").concat(block(sectionContent), "\n                    <!--/").concat(sectionName, "-->\n                "); }));
    }
    var placeForSection = removeContentComments(content).match(/^##.*$/im);
    if (!placeForSection) {
        throw new Error("No place where to put the section <!--".concat(sectionName, "-->"));
    }
    var _a = __read(placeForSection, 1), heading = _a[0];
    return content.replace(heading, "<!--".concat(sectionName, "-->\n").concat(warningLine, "\n").concat(sectionContent, "\n<!--/").concat(sectionName, "-->\n\n").concat(heading));
}

/**
 * Prettify the html code
 *
 * @param content raw html code
 * @returns formatted html code
 */
function prettifyMarkdown(content) {
    try {
        return format(content, {
            parser: 'markdown',
            plugins: [parserHtml],
            // TODO: DRY - make some import or auto-copy of .prettierrc
            endOfLine: 'lf',
            tabWidth: 4,
            singleQuote: true,
            trailingComma: 'all',
            arrowParens: 'always',
            printWidth: 120,
            htmlWhitespaceSensitivity: 'ignore',
            jsxBracketSameLine: false,
            bracketSpacing: true,
        });
    }
    catch (error) {
        console.error('There was an error with prettifying the markdown, using the original as the fallback', {
            error: error,
            html: content,
        });
        return content;
    }
}

/**
 * Creates a Mermaid graph based on the promptbook
 *
 * Note: The result is not wrapped in a Markdown code block
 */
function renderPromptbookMermaid(promptbookJson, options) {
    var _a = (options || {}).linkPromptTemplate, linkPromptTemplate = _a === void 0 ? function () { return null; } : _a;
    var parameterNameToTemplateName = function (parameterName) {
        var parameter = promptbookJson.parameters.find(function (parameter) { return parameter.name === parameterName; });
        if (!parameter) {
            throw new UnexpectedError("Could not find {".concat(parameterName, "}"));
        }
        if (parameter.isInput) {
            return 'input';
        }
        var template = promptbookJson.promptTemplates.find(function (template) { return template.resultingParameterName === parameterName; });
        if (!template) {
            throw new Error("Could not find template for {".concat(parameterName, "}"));
        }
        return normalizeTo_camelCase('template-' + titleToName(template.title));
    };
    var promptbookMermaid = spaceTrim(function (block) { return "\n\n            %% \uD83D\uDD2E Tip: Open this on GitHub or in the VSCode website to see the Mermaid graph visually\n\n            flowchart LR\n              subgraph \"".concat(promptbookJson.title, "\"\n\n                  direction TB\n\n                  input((Input)):::input\n                  ").concat(block(promptbookJson.promptTemplates
        .flatMap(function (_a) {
        var title = _a.title, dependentParameterNames = _a.dependentParameterNames, resultingParameterName = _a.resultingParameterName;
        return __spreadArray([
            "".concat(parameterNameToTemplateName(resultingParameterName), "(\"").concat(title, "\")")
        ], __read(dependentParameterNames.map(function (dependentParameterName) {
            return "".concat(parameterNameToTemplateName(dependentParameterName), "--\"{").concat(dependentParameterName, "}\"-->").concat(parameterNameToTemplateName(resultingParameterName));
        })), false);
    })
        .join('\n')), "\n\n                  ").concat(block(promptbookJson.parameters
        .filter(function (_a) {
        var isOutput = _a.isOutput;
        return isOutput;
    })
        .map(function (_a) {
        var name = _a.name;
        return "".concat(parameterNameToTemplateName(name), "--\"{").concat(name, "}\"-->output");
    })
        .join('\n')), "\n                  output((Output)):::output\n\n                  ").concat(block(promptbookJson.promptTemplates
        .map(function (promptTemplate) {
        var link = linkPromptTemplate(promptTemplate);
        if (link === null) {
            return '';
        }
        var href = link.href, title = link.title;
        var templateName = parameterNameToTemplateName(promptTemplate.resultingParameterName);
        return "click ".concat(templateName, " href \"").concat(href, "\" \"").concat(title, "\";");
    })
        .filter(function (line) { return line !== ''; })
        .join('\n')), "\n\n                  classDef input color: grey;\n                  classDef output color: grey;\n\n              end;\n\n        "); });
    return promptbookMermaid;
}
/**
 * TODO: Maybe use some Mermaid library instead of string templating
 * TODO: [ðŸ•Œ] When more than 2 functionalities, split into separate functions
 */

/**
 * Prettyfies Promptbook string and adds Mermaid graph
 */
function prettifyPromptbookString(promptbookString, options) {
    var isGraphAdded = options.isGraphAdded, isPrettifyed = options.isPrettifyed;
    if (isGraphAdded) {
        var promptbookJson = promptbookStringToJson(promptbookString);
        var promptbookMermaid_1 = renderPromptbookMermaid(promptbookJson, {
            linkPromptTemplate: function (promptTemplate) {
                return { href: "#".concat(promptTemplate.name), title: promptTemplate.title };
            },
        });
        var promptbookMermaidBlock = spaceTrim(function (block) { return "\n            ```mermaid\n            ".concat(block(promptbookMermaid_1), "\n            ```\n        "); });
        promptbookString = addAutoGeneratedSection(promptbookString, {
            sectionName: 'Graph',
            sectionContent: promptbookMermaidBlock,
        });
    }
    if (isPrettifyed) {
        promptbookString = prettifyMarkdown(promptbookString);
    }
    return promptbookString;
}
/**
 * TODO: Maybe use some Mermaid library instead of string templating
 * TODO: [ðŸ•Œ] When more than 2 functionalities, split into separate functions
 */

/**
 * This error indicates that the promptbook object has valid syntax but contains logical errors (like circular dependencies)
 */
var PromptbookLogicError = /** @class */ (function (_super) {
    __extends(PromptbookLogicError, _super);
    function PromptbookLogicError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'PromptbookLogicError';
        Object.setPrototypeOf(_this, PromptbookLogicError.prototype);
        return _this;
    }
    return PromptbookLogicError;
}(Error));

/**
 * Function renameParameter will find all usable parameters for given prompt template
 * In other words, it will find all parameters that are not used in the prompt template itseld and all its dependencies
 *
 * @throws {PromptbookLogicError} If the new parameter name is already used in the promptbook
 */
function renameParameter(options) {
    var e_1, _a, e_2, _b;
    var promptbook = options.promptbook, oldParameterName = options.oldParameterName, newParameterName = options.newParameterName;
    if (promptbook.parameters.some(function (parameter) { return parameter.name === newParameterName; })) {
        throw new PromptbookLogicError("Can not replace {".concat(oldParameterName, "} to {").concat(newParameterName, "} because {").concat(newParameterName, "} is already used in the promptbook"));
    }
    var renamedPromptbook = __assign(__assign({}, promptbook), { parameters: __spreadArray([], __read(promptbook.parameters), false), promptTemplates: __spreadArray([], __read(promptbook.promptTemplates), false) });
    try {
        for (var _c = __values(renamedPromptbook.parameters), _d = _c.next(); !_d.done; _d = _c.next()) {
            var parameter = _d.value;
            if (parameter.name !== oldParameterName) {
                continue;
            }
            parameter.name = newParameterName;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var _e = __values(renamedPromptbook.promptTemplates), _f = _e.next(); !_f.done; _f = _e.next()) {
            var promptTemplate = _f.value;
            if (promptTemplate.resultingParameterName === oldParameterName) {
                promptTemplate.resultingParameterName = newParameterName;
            }
            promptTemplate.dependentParameterNames = promptTemplate.dependentParameterNames.map(function (dependentParameterName) {
                return dependentParameterName === oldParameterName ? newParameterName : dependentParameterName;
            });
            promptTemplate.content = promptTemplate.content.replace(new RegExp("{".concat(oldParameterName, "}"), 'g'), "{".concat(newParameterName, "}"));
            promptTemplate.title = promptTemplate.title.replace(new RegExp("{".concat(oldParameterName, "}"), 'g'), "{".concat(newParameterName, "}"));
            promptTemplate.description =
                promptTemplate.description === undefined
                    ? undefined
                    : promptTemplate.description.replace(new RegExp("{".concat(oldParameterName, "}"), 'g'), "{".concat(newParameterName, "}"));
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return renamedPromptbook;
}

/**
 * This error indicates errors during the execution of the promptbook
 */
var PromptbookExecutionError = /** @class */ (function (_super) {
    __extends(PromptbookExecutionError, _super);
    function PromptbookExecutionError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'PromptbookExecutionError';
        Object.setPrototypeOf(_this, PromptbookExecutionError.prototype);
        return _this;
    }
    return PromptbookExecutionError;
}(Error));

/**
 * Asserts that the execution of a promptnook is successful
 *
 * @param executionResult - The partial result of the promptnook execution
 * @throws {PromptbookExecutionError} If the execution is not successful or if multiple errors occurred
 */
function assertsExecutionSuccessful(executionResult) {
    var isSuccessful = executionResult.isSuccessful, errors = executionResult.errors;
    if (isSuccessful === true) {
        return;
    }
    if (errors.length === 0) {
        throw new PromptbookExecutionError("Promptnook Execution failed because of unknown reason");
    }
    else if (errors.length === 1) {
        throw errors[0];
    }
    else {
        throw new PromptbookExecutionError(spaceTrim(function (block) { return "\n                    Multiple errors occurred during promptnook execution\n\n                    ".concat(block(errors.map(function (error) { return '- ' + error.message; }).join('\n')), "\n                "); }));
    }
}
/**
 * TODO: [ðŸ§ ] Can this return type be better typed than void
 */

/**
 * This error occurs when some expectation is not met in the execution of the pipeline
 *
 * @private Always catched and rethrown as `PromptbookExecutionError`
 * Note: This is a kindof subtype of PromptbookExecutionError
 */
var ExpectError = /** @class */ (function (_super) {
    __extends(ExpectError, _super);
    function ExpectError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'ExpectError';
        Object.setPrototypeOf(_this, ExpectError.prototype);
        return _this;
    }
    return ExpectError;
}(Error));

/**
 * Counts number of characters in the text
 */
function countCharacters(text) {
    // Remove null characters
    text = text.replace(/\0/g, '');
    // Replace emojis (and also ZWJ sequence) with hyphens
    text = text.replace(/(\p{Extended_Pictographic})\p{Modifier_Symbol}/gu, '$1');
    text = text.replace(/(\p{Extended_Pictographic})[\u{FE00}-\u{FE0F}]/gu, '$1');
    text = text.replace(/\p{Extended_Pictographic}(\u{200D}\p{Extended_Pictographic})*/gu, '-');
    return text.length;
}

/**
 * Counts number of lines in the text
 */
function countLines(text) {
    if (text === '') {
        return 0;
    }
    return text.split('\n').length;
}

/**
 * Counts number of pages in the text
 */
function countPages(text) {
    var sentencesPerPage = 5; // Assuming each page has 5 sentences
    var sentences = text.split(/[.!?]+/).filter(function (sentence) { return sentence.trim() !== ''; });
    var pageCount = Math.ceil(sentences.length / sentencesPerPage);
    return pageCount;
}

/**
 * Counts number of paragraphs in the text
 */
function countParagraphs(text) {
    return text.split(/\n\s*\n/).filter(function (paragraph) { return paragraph.trim() !== ''; }).length;
}

/**
 * Split text into sentences
 */
function splitIntoSentences(text) {
    return text.split(/[.!?]+/).filter(function (sentence) { return sentence.trim() !== ''; });
}
/**
 * Counts number of sentences in the text
 */
function countSentences(text) {
    return splitIntoSentences(text).length;
}

var defaultDiacriticsRemovalMap = [
    {
        base: 'A',
        letters: '\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F',
    },
    { base: 'AA', letters: '\uA732' },
    { base: 'AE', letters: '\u00C6\u01FC\u01E2' },
    { base: 'AO', letters: '\uA734' },
    { base: 'AU', letters: '\uA736' },
    { base: 'AV', letters: '\uA738\uA73A' },
    { base: 'AY', letters: '\uA73C' },
    {
        base: 'B',
        letters: '\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181',
    },
    {
        base: 'C',
        letters: '\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E',
    },
    {
        base: 'D',
        letters: '\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779\u00D0',
    },
    { base: 'DZ', letters: '\u01F1\u01C4' },
    { base: 'Dz', letters: '\u01F2\u01C5' },
    {
        base: 'E',
        letters: '\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E',
    },
    { base: 'F', letters: '\u0046\u24BB\uFF26\u1E1E\u0191\uA77B' },
    {
        base: 'G',
        letters: '\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E',
    },
    {
        base: 'H',
        letters: '\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D',
    },
    {
        base: 'I',
        letters: '\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197',
    },
    { base: 'J', letters: '\u004A\u24BF\uFF2A\u0134\u0248' },
    {
        base: 'K',
        letters: '\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2',
    },
    {
        base: 'L',
        letters: '\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780',
    },
    { base: 'LJ', letters: '\u01C7' },
    { base: 'Lj', letters: '\u01C8' },
    { base: 'M', letters: '\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C' },
    {
        base: 'N',
        letters: '\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4',
    },
    { base: 'NJ', letters: '\u01CA' },
    { base: 'Nj', letters: '\u01CB' },
    {
        base: 'O',
        letters: '\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C',
    },
    { base: 'OI', letters: '\u01A2' },
    { base: 'OO', letters: '\uA74E' },
    { base: 'OU', letters: '\u0222' },
    { base: 'OE', letters: '\u008C\u0152' },
    { base: 'oe', letters: '\u009C\u0153' },
    {
        base: 'P',
        letters: '\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754',
    },
    { base: 'Q', letters: '\u0051\u24C6\uFF31\uA756\uA758\u024A' },
    {
        base: 'R',
        letters: '\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782',
    },
    {
        base: 'S',
        letters: '\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784',
    },
    {
        base: 'T',
        letters: '\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786',
    },
    { base: 'TZ', letters: '\uA728' },
    {
        base: 'U',
        letters: '\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244',
    },
    { base: 'V', letters: '\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245' },
    { base: 'VY', letters: '\uA760' },
    {
        base: 'W',
        letters: '\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72',
    },
    { base: 'X', letters: '\u0058\u24CD\uFF38\u1E8A\u1E8C' },
    {
        base: 'Y',
        letters: '\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE',
    },
    {
        base: 'Z',
        letters: '\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762',
    },
    {
        base: 'a',
        letters: '\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250',
    },
    { base: 'aa', letters: '\uA733' },
    { base: 'ae', letters: '\u00E6\u01FD\u01E3' },
    { base: 'ao', letters: '\uA735' },
    { base: 'au', letters: '\uA737' },
    { base: 'av', letters: '\uA739\uA73B' },
    { base: 'ay', letters: '\uA73D' },
    {
        base: 'b',
        letters: '\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253',
    },
    {
        base: 'c',
        letters: '\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184',
    },
    {
        base: 'd',
        letters: '\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A',
    },
    { base: 'dz', letters: '\u01F3\u01C6' },
    {
        base: 'e',
        letters: '\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD',
    },
    { base: 'f', letters: '\u0066\u24D5\uFF46\u1E1F\u0192\uA77C' },
    {
        base: 'g',
        letters: '\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F',
    },
    {
        base: 'h',
        letters: '\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265',
    },
    { base: 'hv', letters: '\u0195' },
    {
        base: 'i',
        letters: '\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131',
    },
    { base: 'j', letters: '\u006A\u24D9\uFF4A\u0135\u01F0\u0249' },
    {
        base: 'k',
        letters: '\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3',
    },
    {
        base: 'l',
        letters: '\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747',
    },
    { base: 'lj', letters: '\u01C9' },
    { base: 'm', letters: '\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F' },
    {
        base: 'n',
        letters: '\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5',
    },
    { base: 'nj', letters: '\u01CC' },
    {
        base: 'o',
        letters: '\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275',
    },
    { base: 'oi', letters: '\u01A3' },
    { base: 'ou', letters: '\u0223' },
    { base: 'oo', letters: '\uA74F' },
    {
        base: 'p',
        letters: '\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755',
    },
    { base: 'q', letters: '\u0071\u24E0\uFF51\u024B\uA757\uA759' },
    {
        base: 'r',
        letters: '\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783',
    },
    {
        base: 's',
        letters: '\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B',
    },
    {
        base: 't',
        letters: '\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787',
    },
    { base: 'tz', letters: '\uA729' },
    {
        base: 'u',
        letters: '\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289',
    },
    { base: 'v', letters: '\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C' },
    { base: 'vy', letters: '\uA761' },
    {
        base: 'w',
        letters: '\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73',
    },
    { base: 'x', letters: '\u0078\u24E7\uFF58\u1E8B\u1E8D' },
    {
        base: 'y',
        letters: '\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF',
    },
    {
        base: 'z',
        letters: '\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763',
    },
];
/**
 * Map of letters from diacritic variant to diacritless variant
 * Contains lowercase and uppercase separatelly
 *
 * > "Ã¡" => "a"
 * > "Ä›" => "e"
 * > "Ä‚" => "A"
 * > ...
 */
var DIACRITIC_VARIANTS_LETTERS = {};
// tslint:disable-next-line: prefer-for-of
for (var i = 0; i < defaultDiacriticsRemovalMap.length; i++) {
    var letters = defaultDiacriticsRemovalMap[i].letters;
    // tslint:disable-next-line: prefer-for-of
    for (var j = 0; j < letters.length; j++) {
        DIACRITIC_VARIANTS_LETTERS[letters[j]] = defaultDiacriticsRemovalMap[i].base;
    }
}
// <- TODO: [ðŸ“] Put to maker function to save execution time if not needed
/*
  @see https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

/**
 *
 */
function removeDiacritics(input) {
    /*eslint no-control-regex: "off"*/
    return input.replace(/[^\u0000-\u007E]/g, function (a) {
        return DIACRITIC_VARIANTS_LETTERS[a] || a;
    });
}

/**
 * Counts number of words in the text
 */
function countWords(text) {
    text = text.replace(/[\p{Extended_Pictographic}]/gu, 'a');
    text = removeDiacritics(text);
    return text.split(/[^a-zÐ°-Ñ0-9]+/i).filter(function (word) { return word.length > 0; }).length;
}

/**
 * Index of all counter functions
 */
var CountUtils = {
    CHARACTERS: countCharacters,
    WORDS: countWords,
    SENTENCES: countSentences,
    PARAGRAPHS: countParagraphs,
    LINES: countLines,
    PAGES: countPages,
};

/**
 * Function checkExpectations will check if the expectations on given value are met
 *
 * Note: There are two simmilar functions:
 * - `checkExpectations` which throws an error if the expectations are not met
 * - `isPassingExpectations` which returns a boolean
 *
 * @throws {ExpectError} if the expectations are not met
 * @returns {void} Nothing
 */
function checkExpectations(expectations, value) {
    var e_1, _a;
    try {
        for (var _b = __values(Object.entries(expectations)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), unit = _d[0], _e = _d[1], max = _e.max, min = _e.min;
            var amount = CountUtils[unit.toUpperCase()](value);
            if (min && amount < min) {
                throw new ExpectError("Expected at least ".concat(min, " ").concat(unit, " but got ").concat(amount));
            } /* not else */
            if (max && amount > max) {
                throw new ExpectError("Expected at most ".concat(max, " ").concat(unit, " but got ").concat(amount));
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
/**
 * Function checkExpectations will check if the expectations on given value are met
 *
 * Note: There are two simmilar functions:
 * - `checkExpectations` which throws an error if the expectations are not met
 * - `isPassingExpectations` which returns a boolean
 *
 * @returns {boolean} True if the expectations are met
 */
function isPassingExpectations(expectations, value) {
    try {
        checkExpectations(expectations, value);
        return true;
    }
    catch (error) {
        if (!(error instanceof ExpectError)) {
            throw error;
        }
        return false;
    }
}
/**
 * TODO: [ðŸ’] Unite object for expecting amount and format
 */

/**
 * This error occurs during the parameter replacement in the template
 *
 * Note: This is a kindof subtype of PromptbookExecutionError because it occurs during the execution of the pipeline
 */
var TemplateError = /** @class */ (function (_super) {
    __extends(TemplateError, _super);
    function TemplateError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'TemplateError';
        Object.setPrototypeOf(_this, TemplateError.prototype);
        return _this;
    }
    return TemplateError;
}(Error));

/**
 * Replaces parameters in template with values from parameters object
 *
 * @param template the template with parameters in {curly} braces
 * @param parameters the object with parameters
 * @returns the template with replaced parameters
 * @throws {TemplateError} if parameter is not defined, not closed, or not opened
 *
 * @private within the createPromptbookExecutor
 */
function replaceParameters(template, parameters) {
    var replacedTemplate = template;
    var match;
    var loopLimit = LOOP_LIMIT;
    var _loop_1 = function () {
        if (loopLimit-- < 0) {
            throw new UnexpectedError('Loop limit reached during parameters replacement in `replaceParameters`');
        }
        var precol = match.groups.precol;
        var parameterName = match.groups.parameterName;
        if (parameterName === '') {
            return "continue";
        }
        if (parameterName.indexOf('{') !== -1 || parameterName.indexOf('}') !== -1) {
            throw new TemplateError('Parameter is already opened or not closed');
        }
        if (parameters[parameterName] === undefined) {
            throw new TemplateError("Parameter {".concat(parameterName, "} is not defined"));
        }
        var parameterValue = parameters[parameterName];
        if (parameterValue === undefined) {
            throw new TemplateError("Parameter {".concat(parameterName, "} is not defined"));
        }
        parameterValue = parameterValue.toString();
        if (parameterValue.includes('\n') && /^\s*\W{0,3}\s*$/.test(precol)) {
            parameterValue = parameterValue
                .split('\n')
                .map(function (line, index) { return (index === 0 ? line : "".concat(precol).concat(line)); })
                .join('\n');
        }
        replacedTemplate =
            replacedTemplate.substring(0, match.index + precol.length) +
                parameterValue +
                replacedTemplate.substring(match.index + precol.length + parameterName.length + 2);
    };
    while ((match = /^(?<precol>.*){(?<parameterName>\w+)}(.*)/m /* <- Not global */
        .exec(replacedTemplate))) {
        _loop_1();
    }
    // [ðŸ’«] Check if there are parameters that are not closed properly
    if (/{\w+$/.test(replacedTemplate)) {
        throw new TemplateError('Parameter is not closed');
    }
    // [ðŸ’«] Check if there are parameters that are not opened properly
    if (/^\w+}/.test(replacedTemplate)) {
        throw new TemplateError('Parameter is not opened');
    }
    return replacedTemplate;
}

/**
 * Format either small or big number
 *
 * @private within the library
 */
function formatNumber(value) {
    if (value === 0) {
        return '0';
    }
    for (var exponent = 0; exponent < 15; exponent++) {
        var factor = Math.pow(10, exponent);
        var valueRounded = Math.round(value * factor) / factor;
        if (Math.abs(value - valueRounded) / value <
            0.001 /* <- TODO: Pass as option, pass to executionReportJsonToString as option */) {
            return valueRounded.toFixed(exponent);
        }
    }
    return value.toString();
}

/**
 * Returns the same value that is passed as argument.
 * No side effects.
 *
 * Note: It can be usefull for leveling indentation
 *
 * @param value any values
 * @returns the same values
 */
function just(value) {
    if (value === undefined) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return undefined;
    }
    return value;
}

/**
 * Create a markdown table from a 2D array of strings
 *
 * @private within the library
 */
function createMarkdownTable(table) {
    var columnWidths = table.reduce(function (widths, row) {
        row.forEach(function (cell, columnIndex) {
            var cellLength = cell.length;
            if (!widths[columnIndex] || cellLength > widths[columnIndex]) {
                widths[columnIndex] = cellLength;
            }
        });
        return widths;
    }, []);
    var header = "| ".concat(table[0]
        .map(function (cell, columnIndex) { return cell.padEnd(columnWidths[columnIndex]); })
        .join(' | '), " |");
    var separator = "|".concat(columnWidths.map(function (width) { return '-'.repeat(width + 2); }).join('|'), "|");
    var rows = table.slice(1).map(function (row) {
        var paddedRow = row.map(function (cell, columnIndex) {
            return cell.padEnd(columnWidths[columnIndex]);
        });
        return "| ".concat(paddedRow.join(' | '), " |");
    });
    return __spreadArray([header, separator], __read(rows), false).join('\n');
}

/**
 * Function createMarkdownChart will draw a chart in markdown from â¬›+ðŸŸ¦ tiles
 *
 * @private within the library
 */
function createMarkdownChart(options) {
    var e_1, _a;
    var nameHeader = options.nameHeader, valueHeader = options.valueHeader, items = options.items, width = options.width, unitName = options.unitName;
    var from = Math.min.apply(Math, __spreadArray([], __read(items.map(function (item) { return item.from; })), false));
    var to = Math.max.apply(Math, __spreadArray([], __read(items.map(function (item) { return item.to; })), false));
    var scale = width / (to - from);
    var table = [[nameHeader, valueHeader]];
    try {
        for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
            var item = items_1_1.value;
            var before = Math.round((item.from - from) * scale);
            var during = Math.round((item.to - item.from) * scale);
            var after = width - before - during;
            table.push([removeEmojis(item.title).trim(), 'â–‘'.repeat(before) + 'â–ˆ'.repeat(during) + 'â–‘'.repeat(after)]);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var legend = "_Note: Each \u2588 represents ".concat(formatNumber(1 / scale), " ").concat(unitName, ", width of ").concat(valueHeader.toLowerCase(), " is ").concat(formatNumber(to - from), " ").concat(unitName, " = ").concat(width, " squares_");
    return createMarkdownTable(table) + '\n\n' + legend;
}
/**
 * TODO: Maybe use Mermain Gant Diagrams
 *       @see https://jojozhuang.github.io/tutorial/mermaid-cheat-sheet/
 */

/**
 * Function escapeMarkdownBlock will escape markdown block if needed
 * It is useful when you want have block in block
 */
function escapeMarkdownBlock(value) {
    return value.replace(/```/g, '\\`\\`\\`');
}

/**
 * Default options for generating an execution report string
 */
var ExecutionReportStringOptionsDefaults = {
    taxRate: 0,
    chartsWidth: 36,
};

/**
 * The thresholds for the relative time in the `moment` library.
 *
 * @see https://momentjscom.readthedocs.io/en/latest/moment/07-customization/13-relative-time-threshold/
 */
var MOMENT_ARG_THRESHOLDS = {
    ss: 3, // <- least number of seconds to be counted in seconds, minus 1. Must be set after setting the `s` unit or without setting the `s` unit.
};

/**
 * Count the duration of working time
 *
 * @private within the library
 */
function countWorkingDuration(items) {
    var e_1, _a;
    var steps = Array.from(new Set(items.flatMap(function (item) { return [item.from, item.to]; })));
    steps.sort(function (a, b) { return a - b; });
    var intervals = steps.map(function (step, index) { return [step, steps[index + 1] || 0]; }).slice(0, -1);
    var duration = 0;
    var _loop_1 = function (interval) {
        var _b = __read(interval, 2), from = _b[0], to = _b[1];
        if (items.some(function (item) { return item.from < to && item.to > from; })) {
            duration += to - from;
        }
    };
    try {
        for (var intervals_1 = __values(intervals), intervals_1_1 = intervals_1.next(); !intervals_1_1.done; intervals_1_1 = intervals_1.next()) {
            var interval = intervals_1_1.value;
            _loop_1(interval);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (intervals_1_1 && !intervals_1_1.done && (_a = intervals_1.return)) _a.call(intervals_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return duration;
}

/**
 * Converts execution report from JSON to string format
 */
function executionReportJsonToString(executionReportJson, options) {
    var e_1, _a;
    var _b, _c, _d, _e, _f, _g;
    var _h = __assign(__assign({}, ExecutionReportStringOptionsDefaults), (options || {})), taxRate = _h.taxRate, chartsWidth = _h.chartsWidth;
    var executionReportString = spaceTrim(function (block) { return "\n            # ".concat(executionReportJson.title || 'Execution report', "\n\n            ").concat(block(executionReportJson.description || ''), "\n          "); });
    var headerList = [];
    if (executionReportJson.promptbookUrl) {
        headerList.push("PROMPTBOOK URL ".concat(executionReportJson.promptbookUrl));
    }
    headerList.push("PROMPTBOOK VERSION ".concat(executionReportJson.promptbookUsedVersion) +
        (!executionReportJson.promptbookRequestedVersion
            ? ''
            : " *(requested ".concat(executionReportJson.promptbookRequestedVersion, ")*")));
    if (executionReportJson.promptExecutions.length !== 0) {
        // TODO: What if startedAt OR/AND completedAt is not defined?
        var startedAt = moment(Math.min.apply(Math, __spreadArray([], __read(executionReportJson.promptExecutions
            .filter(function (promptExecution) { var _a, _b; return (_b = (_a = promptExecution.result) === null || _a === void 0 ? void 0 : _a.timing) === null || _b === void 0 ? void 0 : _b.start; })
            .map(function (promptExecution) { return moment(promptExecution.result.timing.start).valueOf(); })), false)));
        var completedAt = moment(Math.max.apply(Math, __spreadArray([], __read(executionReportJson.promptExecutions
            .filter(function (promptExecution) { var _a, _b; return (_b = (_a = promptExecution.result) === null || _a === void 0 ? void 0 : _a.timing) === null || _b === void 0 ? void 0 : _b.complete; })
            .map(function (promptExecution) { return moment(promptExecution.result.timing.complete).valueOf(); })), false)));
        var timingItems = executionReportJson.promptExecutions.map(function (promptExecution) {
            var _a, _b, _c, _d;
            return ({
                title: promptExecution.prompt.title,
                from: moment((_b = (_a = promptExecution.result) === null || _a === void 0 ? void 0 : _a.timing) === null || _b === void 0 ? void 0 : _b.start).valueOf() / 1000,
                to: moment((_d = (_c = promptExecution.result) === null || _c === void 0 ? void 0 : _c.timing) === null || _d === void 0 ? void 0 : _d.complete).valueOf() / 1000,
            });
        });
        var costItems = executionReportJson.promptExecutions
            .filter(function (promptExecution) { var _a, _b; return typeof ((_b = (_a = promptExecution.result) === null || _a === void 0 ? void 0 : _a.usage) === null || _b === void 0 ? void 0 : _b.price) === 'number'; })
            .map(function (promptExecution) {
            var _a, _b;
            return ({
                title: promptExecution.prompt.title,
                from: 0,
                to: ((_b = (_a = promptExecution.result) === null || _a === void 0 ? void 0 : _a.usage) === null || _b === void 0 ? void 0 : _b.price) * (1 + taxRate),
            });
        });
        var duration = moment.duration(completedAt.diff(startedAt));
        var llmDuration = moment.duration(countWorkingDuration(timingItems) * 1000);
        var executionsWithKnownCost = executionReportJson.promptExecutions.filter(function (promptExecution) { var _a, _b; return (((_b = (_a = promptExecution.result) === null || _a === void 0 ? void 0 : _a.usage) === null || _b === void 0 ? void 0 : _b.price) || 'UNKNOWN') !== 'UNKNOWN'; });
        var cost = executionsWithKnownCost.reduce(function (cost, promptExecution) { return cost + (promptExecution.result.usage.price || 0); }, 0);
        headerList.push("STARTED AT ".concat(moment(startedAt).format("YYYY-MM-DD HH:mm:ss")));
        headerList.push("COMPLETED AT ".concat(moment(completedAt).format("YYYY-MM-DD HH:mm:ss")));
        headerList.push("TOTAL DURATION ".concat(duration.humanize(MOMENT_ARG_THRESHOLDS)));
        headerList.push("TOTAL LLM DURATION ".concat(llmDuration.humanize(MOMENT_ARG_THRESHOLDS)));
        headerList.push("TOTAL COST $".concat(formatNumber(cost * (1 + taxRate))) +
            (executionsWithKnownCost.length === executionReportJson.promptExecutions.length
                ? ''
                : " *(Some cost is unknown)*") +
            (taxRate !== 0 ? " *(with tax ".concat(taxRate * 100, "%)*") : ''));
        executionReportString += '\n\n' + headerList.map(function (header) { return "- ".concat(header); }).join('\n');
        executionReportString +=
            '\n\n' +
                '## ðŸ—ƒ Index' +
                '\n\n' +
                executionReportJson.promptExecutions
                    .map(function (promptExecution) {
                    // TODO: Make some better system to convert hedings to links
                    var hash = normalizeToKebabCase(promptExecution.prompt.title);
                    if (/^\s*\p{Extended_Pictographic}/u.test(promptExecution.prompt.title)) {
                        hash = '-' + hash;
                    }
                    // TODO: Make working hash link for the template in md + pdf
                    return "- [".concat(promptExecution.prompt.title, "](#").concat(hash, ")");
                })
                    .join('\n');
        executionReportString +=
            '\n\n' +
                '## âŒš Time chart' +
                '\n\n' +
                createMarkdownChart({
                    nameHeader: 'Template',
                    valueHeader: 'Timeline',
                    items: timingItems,
                    width: chartsWidth,
                    unitName: 'seconds',
                });
        executionReportString +=
            '\n\n' +
                '## ðŸ’¸ Cost chart' +
                '\n\n' +
                createMarkdownChart({
                    nameHeader: 'Template',
                    valueHeader: 'Cost',
                    items: costItems,
                    width: chartsWidth,
                    unitName: 'USD',
                });
    }
    else {
        headerList.push("TOTAL COST $0 *(Nothing executed)*");
    }
    var _loop_1 = function (promptExecution) {
        executionReportString += '\n\n\n\n' + "## ".concat(promptExecution.prompt.title);
        var templateList = [];
        // TODO: What if startedAt OR/AND completedAt is not defined?
        var startedAt = moment((_c = (_b = promptExecution.result) === null || _b === void 0 ? void 0 : _b.timing) === null || _c === void 0 ? void 0 : _c.start);
        var completedAt = moment((_e = (_d = promptExecution.result) === null || _d === void 0 ? void 0 : _d.timing) === null || _e === void 0 ? void 0 : _e.complete);
        var duration = moment.duration(completedAt.diff(startedAt));
        // Not need here:
        // > templateList.push(`STARTED AT ${moment(startedAt).calendar()}`);
        templateList.push("DURATION ".concat(duration.humanize(MOMENT_ARG_THRESHOLDS)));
        if (typeof ((_g = (_f = promptExecution.result) === null || _f === void 0 ? void 0 : _f.usage) === null || _g === void 0 ? void 0 : _g.price) === 'number') {
            templateList.push("COST $".concat(formatNumber(promptExecution.result.usage.price * (1 + taxRate))) +
                (taxRate !== 0 ? " *(with tax ".concat(taxRate * 100, "%)*") : ''));
        }
        else {
            templateList.push("COST UNKNOWN");
        }
        executionReportString += '\n\n' + templateList.map(function (header) { return "- ".concat(header); }).join('\n');
        /*
          -   MODEL VARIANT ${promptExecution.prompt.modelRequirements.modelVariant}
                -   MODEL NAME \`${promptExecution.result?.model}\` (requested \`${
                    promptExecution.prompt.modelRequirements.modelName

        */
        if (just(true)) {
            executionReportString +=
                '\n\n\n\n' +
                    spaceTrim(function (block) { return "\n\n                        ### Prompt\n\n                        ```\n                        ".concat(block(escapeMarkdownBlock(promptExecution.prompt.content)), "\n                        ```\n\n                    "); });
        }
        if (promptExecution.result && promptExecution.result.content) {
            executionReportString +=
                '\n\n\n\n' +
                    spaceTrim(function (block) { return "\n\n                        ### Result\n\n                        ```\n                        ".concat(block(escapeMarkdownBlock(promptExecution.result.content)), "\n                        ```\n                    "); });
        }
        if (promptExecution.error && promptExecution.error.message) {
            executionReportString +=
                '\n\n\n\n' +
                    spaceTrim(function (block) { return "\n\n                        ### Error\n\n                        ```\n                        ".concat(block(escapeMarkdownBlock(promptExecution.error.message)), "\n                        ```\n\n                    "); });
        }
    };
    try {
        for (var _j = __values(executionReportJson.promptExecutions), _k = _j.next(); !_k.done; _k = _j.next()) {
            var promptExecution = _k.value;
            _loop_1(promptExecution);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_k && !_k.done && (_a = _j.return)) _a.call(_j);
        }
        finally { if (e_1) throw e_1.error; }
    }
    executionReportString = prettifyMarkdown(executionReportString);
    return executionReportString;
}
/**
 * TODO: Add mermaid chart for every report
 * TODO: [ðŸ§ ] Allow to filter out some parts of the report by options
 */

/**
 * Function isValidJsonString will tell you if the string is valid JSON or not
 */
function isValidJsonString(value) {
    try {
        JSON.parse(value);
        return true;
    }
    catch (error) {
        if (!(error instanceof Error)) {
            throw error;
        }
        if (error.message.includes('Unexpected token')) {
            return false;
        }
        return false;
    }
}

/**
 * Makes first letter of a string uppercase
 *
 */
function decapitalize(word) {
    return word.substring(0, 1).toLowerCase() + word.substring(1);
}

/* tslint:disable */
/*
TODO: Tests
expect(encodeRoutePath({ uriId: 'VtG7sR9rRJqwNEdM2', name: 'Moje tabule' })).toEqual('/VtG7sR9rRJqwNEdM2/Moje tabule');
expect(encodeRoutePath({ uriId: 'VtG7sR9rRJqwNEdM2', name: 'Ä›Å¡ÄÅ™Å¾Å¾Ã½Ã¡Ã­ÃºÅ¯' })).toEqual('/VtG7sR9rRJqwNEdM2/escrzyaieuu');
expect(encodeRoutePath({ uriId: 'VtG7sR9rRJqwNEdM2', name: '  ahoj  ' })).toEqual('/VtG7sR9rRJqwNEdM2/ahoj');
expect(encodeRoutePath({ uriId: 'VtG7sR9rRJqwNEdM2', name: '  ahoj_ahojAhoj    ahoj  ' })).toEqual('/VtG7sR9rRJqwNEdM2/ahoj-ahoj-ahoj-ahoj');
*/
function normalizeTo_SCREAMING_CASE(sentence) {
    var e_1, _a;
    var charType;
    var lastCharType = 'OTHER';
    var normalizedName = '';
    try {
        for (var sentence_1 = __values(sentence), sentence_1_1 = sentence_1.next(); !sentence_1_1.done; sentence_1_1 = sentence_1.next()) {
            var char = sentence_1_1.value;
            var normalizedChar = void 0;
            if (/^[a-z]$/.test(char)) {
                charType = 'LOWERCASE';
                normalizedChar = char.toUpperCase();
            }
            else if (/^[A-Z]$/.test(char)) {
                charType = 'UPPERCASE';
                normalizedChar = char;
            }
            else if (/^[0-9]$/.test(char)) {
                charType = 'NUMBER';
                normalizedChar = char;
            }
            else if (/^\/$/.test(char)) {
                charType = 'SLASH';
                normalizedChar = char;
            }
            else {
                charType = 'OTHER';
                normalizedChar = '_';
            }
            if (charType !== lastCharType &&
                !(lastCharType === 'UPPERCASE' && charType === 'LOWERCASE') &&
                !(lastCharType === 'NUMBER') &&
                !(charType === 'NUMBER')) {
                normalizedName += '_';
            }
            normalizedName += normalizedChar;
            lastCharType = charType;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (sentence_1_1 && !sentence_1_1.done && (_a = sentence_1.return)) _a.call(sentence_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    normalizedName = normalizedName.replace(/_+/g, '_');
    normalizedName = normalizedName.replace(/_?\/_?/g, '/');
    normalizedName = normalizedName.replace(/^_/, '');
    normalizedName = normalizedName.replace(/_$/, '');
    return normalizedName;
}
/**
 * TODO: [ðŸŒº] Use some intermediate util splitWords
 */

/**
 * Parses keywords from a string
 *
 * @param {string} input
 * @returns {Set} of keywords without diacritics in lowercase
 */
function parseKeywordsFromString(input) {
    var keywords = normalizeTo_SCREAMING_CASE(removeDiacritics(input))
        .toLowerCase()
        .split(/[^a-z0-9]+/gs)
        .filter(function (value) { return value; });
    return new Set(keywords);
}

/**
 * Tests if keyword is valid
 *
 * @param keyword to test
 * @returns if keyword is valid or not
 */
function isValidKeyword(keyword) {
    var keywordParsed = parseKeywordsFromString(keyword);
    if (keywordParsed.size !== 1) {
        return false;
    }
    var keywordParsedArray = Array.from(keywordParsed);
    var keywordParsedFirst = keywordParsedArray[0];
    return keywordParsedFirst === keyword;
}

function nameToUriPart(name) {
    var uriPart = name;
    uriPart = uriPart.toLowerCase();
    uriPart = removeDiacritics(uriPart);
    uriPart = uriPart.replace(/[^a-zA-Z0-9]+/g, '-');
    uriPart = uriPart.replace(/^-+/, '');
    uriPart = uriPart.replace(/-+$/, '');
    return uriPart;
}

function nameToUriParts(name) {
    return nameToUriPart(name)
        .split('-')
        .filter(function (value) { return value !== ''; });
}

/* tslint:disable */
function normalizeToKebabCase(sentence) {
    var e_1, _a;
    sentence = removeDiacritics(sentence);
    var charType;
    var lastCharType = 'OTHER';
    var normalizedName = '';
    try {
        for (var sentence_1 = __values(sentence), sentence_1_1 = sentence_1.next(); !sentence_1_1.done; sentence_1_1 = sentence_1.next()) {
            var char = sentence_1_1.value;
            var normalizedChar = void 0;
            if (/^[a-z]$/.test(char)) {
                charType = 'LOWERCASE';
                normalizedChar = char;
            }
            else if (/^[A-Z]$/.test(char)) {
                charType = 'UPPERCASE';
                normalizedChar = char.toLowerCase();
            }
            else if (/^[0-9]$/.test(char)) {
                charType = 'NUMBER';
                normalizedChar = char;
            }
            else if (/^\/$/.test(char)) {
                charType = 'SLASH';
                normalizedChar = char;
            }
            else {
                charType = 'OTHER';
                normalizedChar = '-';
            }
            if (charType !== lastCharType &&
                !(lastCharType === 'UPPERCASE' && charType === 'LOWERCASE') &&
                !(lastCharType === 'NUMBER') &&
                !(charType === 'NUMBER')) {
                normalizedName += '-';
            }
            normalizedName += normalizedChar;
            lastCharType = charType;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (sentence_1_1 && !sentence_1_1.done && (_a = sentence_1.return)) _a.call(sentence_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    normalizedName = normalizedName.split(/-+/g).join('-');
    normalizedName = normalizedName.split(/-?\/-?/g).join('/');
    normalizedName = normalizedName.replace(/^-/, '');
    normalizedName = normalizedName.replace(/-$/, '');
    return normalizedName;
}

/* tslint:disable */
function normalizeTo_camelCase(sentence, __firstLetterCapital) {
    var e_1, _a;
    if (__firstLetterCapital === void 0) { __firstLetterCapital = false; }
    var charType;
    var lastCharType = null;
    var normalizedName = '';
    try {
        for (var sentence_1 = __values(sentence), sentence_1_1 = sentence_1.next(); !sentence_1_1.done; sentence_1_1 = sentence_1.next()) {
            var char = sentence_1_1.value;
            var normalizedChar = void 0;
            if (/^[a-z]$/.test(char)) {
                charType = 'LOWERCASE';
                normalizedChar = char;
            }
            else if (/^[A-Z]$/.test(char)) {
                charType = 'UPPERCASE';
                normalizedChar = char.toLowerCase();
            }
            else if (/^[0-9]$/.test(char)) {
                charType = 'NUMBER';
                normalizedChar = char;
            }
            else {
                charType = 'OTHER';
                normalizedChar = '';
            }
            if (!lastCharType) {
                if (__firstLetterCapital) {
                    normalizedChar = normalizedChar.toUpperCase(); //TODO: DRY
                }
            }
            else if (charType !== lastCharType &&
                !(charType === 'LOWERCASE' && lastCharType === 'UPPERCASE') &&
                !(lastCharType === 'NUMBER') &&
                !(charType === 'NUMBER')) {
                normalizedChar = normalizedChar.toUpperCase(); //TODO: [ðŸŒº] DRY
            }
            normalizedName += normalizedChar;
            lastCharType = charType;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (sentence_1_1 && !sentence_1_1.done && (_a = sentence_1.return)) _a.call(sentence_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return normalizedName;
}
/**
 * TODO: [ðŸŒº] Use some intermediate util splitWords
 */

function normalizeTo_PascalCase(sentence) {
    return normalizeTo_camelCase(sentence, true);
}

/* tslint:disable */
function normalizeTo_snake_case(sentence) {
    return normalizeTo_SCREAMING_CASE(sentence).toLowerCase();
}

/**
 * Take every whitespace (space, new line, tab) and replace it with a single space.
 */
function normalizeWhitespaces(sentence) {
    return sentence.replace(/\s+/gs, ' ').trim();
}

/**
 * Parses keywords from any object and recursively walks through
 *
 * Tip: If you want to parse multiple inputs, just wrap them in an array
 *
 * @param input of any kind
 * @returns {Set} of keywords without diacritics in lowercase
 */
function parseKeywords(input) {
    if (typeof input === 'string') {
        return parseKeywordsFromString(input);
    }
    else if (typeof input === 'object') {
        if (Array.isArray(input)) {
            return input.map(parseKeywords).reduce(function (a, b) { return new Set(__spreadArray(__spreadArray([], __read(a), false), __read(b), false)); }, new Set());
        }
        else if (input === null) {
            return new Set();
        }
        else {
            return parseKeywords(Object.values(input));
        }
    }
    else {
        return new Set();
    }
}
/**
 * Note: Not using spread in input param because of keeping second parameter for options
 * TODO: [ðŸŒº] Use some intermediate util splitWords
 */

/**
 *
 */
function searchKeywords(haystack, needle) {
    var e_1, _a;
    var _loop_1 = function (needleWord) {
        if (!__spreadArray([], __read(haystack), false).some(function (haystackWord) {
            return haystackWord.substring(0, needleWord.length) === needleWord;
        })) {
            return { value: false };
        }
    };
    try {
        for (var needle_1 = __values(needle), needle_1_1 = needle_1.next(); !needle_1_1.done; needle_1_1 = needle_1.next()) {
            var needleWord = needle_1_1.value;
            var state_1 = _loop_1(needleWord);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (needle_1_1 && !needle_1_1.done && (_a = needle_1.return)) _a.call(needle_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return true;
}

/**
 * Extracts code block from markdown.
 *
 * Note: If there are multiple or no code blocks the function throws an error
 *
 * Note: There are 3 simmilar function:
 * - `extractBlock` just extracts the content of the code block which is also used as build-in function for postprocessing
 * - `extractOneBlockFromMarkdown` extracts exactly one code block with language of the code block
 * - `extractAllBlocksFromMarkdown` extracts all code blocks with language of the code block
 */
function extractBlock(markdown) {
    var content = extractOneBlockFromMarkdown(markdown).content;
    return content;
}
//

/**
 * Removes quotes from a string
 *
 * Tip: This is very usefull for post-processing of the result of the LLM model
 * Note: This function removes only the same quotes from the beginning and the end of the string
 * Note: There are two simmilar functions:
 * - `removeQuotes` which removes only bounding quotes
 * - `unwrapResult` which removes whole introduce sentence
 *
 * @param text optionally quoted text
 * @returns text without quotes
 */
function removeQuotes(text) {
    if (text.startsWith('"') && text.endsWith('"')) {
        return text.slice(1, -1);
    }
    if (text.startsWith('\'') && text.endsWith('\'')) {
        return text.slice(1, -1);
    }
    return text;
}

/**
 * Function trimCodeBlock will trim starting and ending code block from the string if it is present.
 *
 * Note: This is usefull for post-processing of the result of the chat LLM model
 *       when the model wraps the result in the (markdown) code block.
 *
 */
function trimCodeBlock(value) {
    value = spaceTrim(value);
    if (!/^```[a-z]*(.*)```$/is.test(value)) {
        return value;
    }
    value = value.replace(/^```[a-z]*/i, '');
    value = value.replace(/```$/i, '');
    value = spaceTrim(value);
    return value;
}

/**
 * Function trimEndOfCodeBlock will remove ending code block from the string if it is present.
 *
 * Note: This is usefull for post-processing of the result of the completion LLM model
 *       if you want to start code block in the prompt but you don't want to end it in the result.
 */
function trimEndOfCodeBlock(value) {
    value = spaceTrim(value);
    value = value.replace(/```$/g, '');
    value = spaceTrim(value);
    return value;
}

/**
 * Removes quotes and optional introduce text from a string
 *
 * Tip: This is very usefull for post-processing of the result of the LLM model
 * Note: This function trims the text and removes whole introduce sentence if it is present
 * Note: There are two simmilar functions:
 * - `removeQuotes` which removes only bounding quotes
 * - `unwrapResult` which removes whole introduce sentence
 *
 * @param text optionally quoted text
 * @returns text without quotes
 */
function unwrapResult(text, options) {
    var _a = options || {}, _b = _a.isTrimmed, isTrimmed = _b === void 0 ? true : _b, _c = _a.isIntroduceSentenceRemoved, isIntroduceSentenceRemoved = _c === void 0 ? true : _c;
    var trimmedText = text;
    // Remove leading and trailing spaces and newlines
    if (isTrimmed) {
        trimmedText = spaceTrim(trimmedText);
    }
    var processedText = trimmedText;
    if (isIntroduceSentenceRemoved) {
        var introduceSentenceRegex = /^[a-zÄ›Å¡ÄÅ™Å¾Ã½Ã¡Ã­Ã©ÃºÅ¯:\s]*:\s*/i;
        if (introduceSentenceRegex.test(text)) {
            // Remove the introduce sentence and quotes by replacing it with an empty string
            processedText = processedText.replace(introduceSentenceRegex, '');
        }
        processedText = spaceTrim(processedText);
    }
    if (processedText.length < 3) {
        return trimmedText;
    }
    if (processedText.includes('\n')) {
        return trimmedText;
    }
    // Remove the quotes by extracting the substring without the first and last characters
    var unquotedText = processedText.slice(1, -1);
    // Check if the text starts and ends with quotes
    if ([
        ['"', '"'],
        ["'", "'"],
        ['`', '`'],
        ['*', '*'],
        ['_', '_'],
        ['â€ž', 'â€œ'],
        ['Â«', 'Â»'] /* <- QUOTES to config */,
    ].some(function (_a) {
        var _b = __read(_a, 2), startQuote = _b[0], endQuote = _b[1];
        if (!processedText.startsWith(startQuote)) {
            return false;
        }
        if (!processedText.endsWith(endQuote)) {
            return false;
        }
        if (unquotedText.includes(startQuote) && !unquotedText.includes(endQuote)) {
            return false;
        }
        if (!unquotedText.includes(startQuote) && unquotedText.includes(endQuote)) {
            return false;
        }
        return true;
    })) {
        return unwrapResult(unquotedText, { isTrimmed: false, isIntroduceSentenceRemoved: false });
    }
    else {
        return processedText;
    }
}
/**
 * TODO: [ðŸ§ ] Should this also unwrap the (parenthesis)
 */

// And the normalization (originally n12 library) utilities:
var normalizeTo = {
    // [ðŸ•™] lowercase: normalizeTo_lowercase,
    // [ðŸ•™] UPPERCASE: normalizeTo_UPPERCASE,
    camelCase: normalizeTo_camelCase,
    PascalCase: normalizeTo_PascalCase,
    SCREAMING_CASE: normalizeTo_SCREAMING_CASE,
    snake_case: normalizeTo_snake_case,
    'kebab-case': normalizeToKebabCase,
};
/**
 * TODO: [ðŸ§ ] Maybe create some indipendent package like `markdown-tools` from both here exported and @private utilities
 * Note: [ðŸ•™] It does not make sence to have simple lower / UPPER case normalization
 */

export { CountUtils, DIACRITIC_VARIANTS_LETTERS, ExecutionReportStringOptionsDefaults, assertsExecutionSuccessful, capitalize, checkExpectations, countCharacters, countLines, countPages, countParagraphs, countSentences, countWords, decapitalize, executionReportJsonToString, extractAllBlocksFromMarkdown, extractAllListItemsFromMarkdown, extractBlock, extractOneBlockFromMarkdown, isPassingExpectations, isValidJsonString, isValidKeyword, nameToUriPart, nameToUriParts, normalizeTo, normalizeToKebabCase, normalizeTo_PascalCase, normalizeTo_SCREAMING_CASE, normalizeTo_camelCase, normalizeTo_snake_case, normalizeWhitespaces, parseKeywords, parseKeywordsFromString, parseNumber, prettifyPromptbookString, removeContentComments, removeDiacritics, removeEmojis, removeMarkdownFormatting, removeQuotes, renameParameter, renderPromptbookMermaid, replaceParameters, searchKeywords, splitIntoSentences, titleToName, trimCodeBlock, trimEndOfCodeBlock, unwrapResult };
//# sourceMappingURL=index.es.js.map
