{"version":3,"file":"gherkin.js","sourceRoot":"","sources":["../../src/api/gherkin.ts"],"names":[],"mappings":";;;AAAA,+DAGkC;AAElC,2DAA+D;AAIxD,KAAK,UAAU,mBAAmB,CAAC,EACxC,KAAK,EACL,GAAG,EACH,WAAW,EACX,WAAW,EACX,UAAU,GAOX;IAIC,MAAM,YAAY,GAAG,IAAI,qBAAY,EAAE,CAAA;IACvC,MAAM,WAAW,GAAiB,EAAE,CAAA;IACpC,MAAM,gBAAgB,CACpB,WAAW,EACX;QACE,KAAK;QACL,UAAU,EAAE,GAAG;QACf,cAAc,EAAE,WAAW,CAAC,cAAc;KAC3C,EACD,CAAC,QAAQ,EAAE,EAAE;QACX,YAAY,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;QAC7B,IAAI,QAAQ,CAAC,UAAU,EAAE;YACvB,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAA;SACtC;QACD,UAAU,EAAE,CAAC,QAAQ,CAAC,CAAA;IACxB,CAAC,CACF,CAAA;IACD,MAAM,iBAAiB,GAAG,YAAY,CAAC,UAAU,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE;QACjE,MAAM,eAAe,GAAG,YAAY;aACjC,mBAAmB,EAAE;aACrB,IAAI,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,GAAG,KAAK,MAAM,CAAC,GAAG,CAAC,CAAA;QACxC,MAAM,QAAQ,GAAG,YAAY,CAAC,WAAW,CACvC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAChD,CAAA;QACD,OAAO;YACL,eAAe;YACf,QAAQ;YACR,MAAM;SACP,CAAA;IACH,CAAC,CAAC,CAAA;IACF,OAAO;QACL,iBAAiB;QACjB,WAAW;KACZ,CAAA;AACH,CAAC;AAlDD,kDAkDC;AAED,KAAK,UAAU,gBAAgB,CAC7B,KAAe,EACf,OAA8B,EAC9B,UAAwC;IAExC,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACrC,MAAM,oBAAoB,GAAG,gCAAc,CAAC,SAAS,CAAC,KAAK,EAAE,OAAO,CAAC,CAAA;QACrE,oBAAoB,CAAC,EAAE,CAAC,MAAM,EAAE,UAAU,CAAC,CAAA;QAC3C,oBAAoB,CAAC,EAAE,CAAC,KAAK,EAAE,OAAO,CAAC,CAAA;QACvC,oBAAoB,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAA;IAC1C,CAAC,CAAC,CAAA;AACJ,CAAC","sourcesContent":["import {\n  GherkinStreams,\n  IGherkinStreamOptions,\n} from '@cucumber/gherkin-streams'\nimport { Envelope, IdGenerator, ParseError } from '@cucumber/messages'\nimport { Query as GherkinQuery } from '@cucumber/gherkin-utils'\nimport { IFilterablePickle } from '../filter'\nimport { ISourcesCoordinates } from './types'\n\nexport async function getPicklesAndErrors({\n  newId,\n  cwd,\n  sourcePaths,\n  coordinates,\n  onEnvelope,\n}: {\n  newId: IdGenerator.NewId\n  cwd: string\n  sourcePaths: string[]\n  coordinates: ISourcesCoordinates\n  onEnvelope?: (envelope: Envelope) => void\n}): Promise<{\n  filterablePickles: readonly IFilterablePickle[]\n  parseErrors: ParseError[]\n}> {\n  const gherkinQuery = new GherkinQuery()\n  const parseErrors: ParseError[] = []\n  await gherkinFromPaths(\n    sourcePaths,\n    {\n      newId,\n      relativeTo: cwd,\n      defaultDialect: coordinates.defaultDialect,\n    },\n    (envelope) => {\n      gherkinQuery.update(envelope)\n      if (envelope.parseError) {\n        parseErrors.push(envelope.parseError)\n      }\n      onEnvelope?.(envelope)\n    }\n  )\n  const filterablePickles = gherkinQuery.getPickles().map((pickle) => {\n    const gherkinDocument = gherkinQuery\n      .getGherkinDocuments()\n      .find((doc) => doc.uri === pickle.uri)\n    const location = gherkinQuery.getLocation(\n      pickle.astNodeIds[pickle.astNodeIds.length - 1]\n    )\n    return {\n      gherkinDocument,\n      location,\n      pickle,\n    }\n  })\n  return {\n    filterablePickles,\n    parseErrors,\n  }\n}\n\nasync function gherkinFromPaths(\n  paths: string[],\n  options: IGherkinStreamOptions,\n  onEnvelope: (envelope: Envelope) => void\n): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const gherkinMessageStream = GherkinStreams.fromPaths(paths, options)\n    gherkinMessageStream.on('data', onEnvelope)\n    gherkinMessageStream.on('end', resolve)\n    gherkinMessageStream.on('error', reject)\n  })\n}\n"]}